process_specification:
    # See the restriction card in the .al: The scalars are massless!
    name: "pentagon"
    generate_from_topo_list: true

    # put here the topology list
    topologies:
        - topo1x1Only:
              definition:
                  [
                      ["q1", 1, 101],
                      ["q2", 2, 102],
                      ["p1", 102, 101],
                      ["p2", 101, 103],
                      ["p3", 103, 104],
                      ["p4", 104, 105],
                      ["p5", 105, 102],
                      ["pout3", 103, 3],
                      ["pout4", 104, 4],
                      ["pout5", 105, 5],
                  ]
              pdgs: [666, 666, 666, 666, 666, 666, 666, 666, 666, 666]
              
              externals: [["q1", "q2"], ["pout3", "pout4", "pout5"]]
              lmb: ["p1"]
              numerator: "1"
        - topo1x1Only:
              definition:
                  [
                      ["q1", 1, 101],
                      ["q2", 2, 102],
                      ["p1", 102, 101],
                      ["p2", 101, 103],
                      ["p3", 103, 104],
                      ["p4", 104, 105],
                      ["p5", 105, 102],
                      ["pout3", 103, 3],
                      ["pout4", 104, 4],
                      ["pout5", 105, 5],
                  ]
              pdgs: [666, 666, 666, 666, 666, 666, 666, 666, 666, 666]
              
              externals: [["q1", "q2"], ["pout3", "pout4", "pout5"]]
              lmb: ["p1"]
              numerator: "-(xZenoConst1*(sp(k1, k1) + 2*sp(k1, p1) + sp(p1, p1))*(sp(k1, k1) + 2*sp(k1, p1) - 2*sp(k1, p3) + sp(p1, p1) - 2*sp(p3, p1) + sp(p3, p3)))"
        - topo1x2Only:
              definition:
                  [
                      ["q1", 1, 101],
                      ["q2", 2, 102],
                      ["p1", 102, 101],
                      ["p2", 101, 103],
                      ["p3", 103, 104],
                      ["p4", 104, 105],
                      ["p5", 105, 102],
                      ["pout3", 103, 3],
                      ["pout4", 104, 4],
                      ["pout5", 105, 5],
                  ]
              pdgs: [666, 666, 666, 666, 666, 666, 666, 666, 666, 666]
              
              externals: [["q1", "q2"], ["pout3", "pout4", "pout5"]]
              lmb: ["p1"]
              numerator: "xZenoConst2*(sp(k1, k1) + 2*sp(k1, p1) + sp(p1, p1))*(sp(k1, k1) + 2*sp(k1, p1) - 2*sp(k1, p3) + sp(p1, p1) - 2*sp(p3, p1) + sp(p3, p3) - 2*sp(p4, k1) - 2*sp(p4, p1) + 2*sp(p4, p3) + sp(p4, p4))"
        - topo1x3Only:
              definition:
                  [
                      ["q1", 1, 101],
                      ["q2", 2, 102],
                      ["p1", 102, 101],
                      ["p2", 101, 103],
                      ["p3", 103, 104],
                      ["p4", 104, 105],
                      ["p5", 105, 102],
                      ["pout3", 103, 3],
                      ["pout4", 104, 4],
                      ["pout5", 105, 5],
                  ]
              pdgs: [666, 666, 666, 666, 666, 666, 666, 666, 666, 666]
              
              externals: [["q1", "q2"], ["pout3", "pout4", "pout5"]]
              lmb: ["p1"]
              numerator: "xZenoConst3*(sp(k1, k1) + 2*sp(k1, p1) - 2*sp(k1, p3) + sp(p1, p1) - 2*sp(p3, p1) + sp(p3, p3))*(sp(k1, k1) + 2*sp(k1, p1) - 2*sp(k1, p3) + sp(p1, p1) - 2*sp(p3, p1) + sp(p3, p3) - 2*sp(p4, k1) - 2*sp(p4, p1) + 2*sp(p4, p3) + sp(p4, p4))"
        - topo1x4Only:
              definition:
                  [
                      ["q1", 1, 101],
                      ["q2", 2, 102],
                      ["p1", 102, 101],
                      ["p2", 101, 103],
                      ["p3", 103, 104],
                      ["p4", 104, 105],
                      ["p5", 105, 102],
                      ["pout3", 103, 3],
                      ["pout4", 104, 4],
                      ["pout5", 105, 5],
                  ]
              pdgs: [666, 666, 666, 666, 666, 666, 666, 666, 666, 666]
              
              externals: [["q1", "q2"], ["pout3", "pout4", "pout5"]]
              lmb: ["p1"]
              numerator: "xZenoConst4*(sp(k1, k1) - 2*sp(k1, p2) + sp(p2, p2))*(sp(k1, k1) + 2*sp(k1, p1) - 2*sp(k1, p3) + sp(p1, p1) - 2*sp(p3, p1) + sp(p3, p3))"
        - topo1x5Only:
              definition:
                  [
                      ["q1", 1, 101],
                      ["q2", 2, 102],
                      ["p1", 102, 101],
                      ["p2", 101, 103],
                      ["p3", 103, 104],
                      ["p4", 104, 105],
                      ["p5", 105, 102],
                      ["pout3", 103, 3],
                      ["pout4", 104, 4],
                      ["pout5", 105, 5],
                  ]
              pdgs: [666, 666, 666, 666, 666, 666, 666, 666, 666, 666]
              numerator: "xZenoConst5*(sp(k1, k1) - 2*sp(k1, p2) + sp(p2, p2))*(sp(k1, k1) + 2*sp(k1, p1) - 2*sp(k1, p3) + sp(p1, p1) - 2*sp(p3, p1) + sp(p3, p3) - 2*sp(p4, k1) - 2*sp(p4, p1) + 2*sp(p4, p3) + sp(p4, p4))"
              externals: [["q1", "q2"], ["pout3", "pout4", "pout5"]]
              lmb: ["p1"]
              
    # The constants have to be real and start with x to be understood by FORM as symbols
    constants:
        xZenoConst1: 0.0053650140884830586537 #works
        xZenoConst2: 0.0036244527077015446119 # works
        xZenoConst3: -0.012881162641930610747 # works
        xZenoConst4: -0.36961316479565609284 # works
        xZenoConst5: 0.10336086045121994676 # works
    external_data:
        n_in: 2
        n_out: 3
        in_momenta: [[1, 0, 0, 1], [-1, 0, 0, 1]]
        out_momenta:
            [
                [0.,2.3,0.2,1.1],
                [0.,0.2,1.3,3.123],
            ]
        # The following are complex valued: compenents are [Real part, Imaginary part]
        spinor_v: []
        spinor_vbar: []
        spinor_u: []
        spinor_ubar: []
        pol: []
        cpol: []
    # FOR now, leave these as they are
    interference_type: "effective_vertex" # alternative: "squared"
    # set the path to mock-up dictionary encoding the amplitude
    math_sg: ""
    perform_color: True # for now, always leave that
    generate_from_math: True
    # if true: the color structure per graph will be factorized: e.g. Tr[T^a T^b T^c]-Tr[T^a T^c T^b] will be treated as ``independent'' color-structure
    # if false: every structure is treated independently
    #   Example
    #  q q~ > g g:    True:     3 color-structures appear {T^a T^b T^c,T^a T^c T^b,T^a T^b T^c-T^a T^c T^b} where the last one is due to the 3g-vertex
    #                 False:    2 color-structures for all diagrams {T^a T^b T^c,T^a T^c T^b}
    color_per_graph: False
